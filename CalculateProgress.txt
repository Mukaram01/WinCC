// CalculateProgress.c â€” % and planned end timestamp from START_DATE+TIME + planned duration
#include "apdefap.h"

static int parse_hhmm(const char* s,int* h,int* m){
    if(!s||s[2]!=':')return 0;
    if(s[0]<'0'||s[0]>'9'||s[1]<'0'||s[1]>'9'||s[3]<'0'||s[3]>'9'||s[4]<'0'||s[4]>'9')return 0;
    *h=(s[0]-'0')*10+(s[1]-'0'); *m=(s[3]-'0')*10+(s[4]-'0');
    return (*h>=0&&*h<=23&&*m>=0&&*m<=59);
}
static int parse_ddmmyyyy(const char* s,int* d,int* mo,int* y){
    if(!s||s[2]!='/'||s[5]!='/')return 0;
    if(s[0]<'0'||s[0]>'9'||s[1]<'0'||s[1]>'9'||s[3]<'0'||s[3]>'9'||s[4]<'0'||s[4]>'9')return 0;
    if(s[6]<'0'||s[6]>'9'||s[7]<'0'||s[7]>'9'||s[8]<'0'||s[8]>'9'||s[9]<'0'||s[9]>'9')return 0;
    *d=(s[0]-'0')*10+(s[1]-'0'); *mo=(s[3]-'0')*10+(s[4]-'0'); *y=(s[6]-'0')*1000+(s[7]-'0')*100+(s[8]-'0')*10+(s[9]-'0');
    return (*d>=1&&*d<=31&&*mo>=1&&*mo<=12&&*y>=1970);
}

void CalculateProgress(const char* startTimeTag,
                       const char* startDateTag,
                       const char* estDurationTag,
                       const char* downtimeTag,
                       const char* percentageTag,
                       const char* endTimeTag,
                       const char* endDayTag,
                       const char* progRuntimeTag)
{
    double est  = GetTagDouble(estDurationTag);
    double down = GetTagDouble(downtimeTag);
    double prog = GetTagDouble(progRuntimeTag);
    double total, pct;

    if(est<0.0) est=0.0; if(down<0.0) down=0.0; if(prog<0.0) prog=0.0;

    total = est + down;
    pct = (total>0.0)? (prog/total)*100.0 : 0.0;
    if(pct<0.0) pct=0.0; if(pct>100.0) pct=100.0;
    SetTagDouble(percentageTag, pct);

    if((endDayTag && endDayTag[0]!='\0') || (endTimeTag && endTimeTag[0]!='\0')){
        const char* st = GetTagChar(startTimeTag);
        const char* sd = GetTagChar(startDateTag);
        int hh=0, mm=0, dd=0, mon=0, yy=0;
        if(st&&sd&&parse_hhmm(st,&hh,&mm)&&parse_ddmmyyyy(sd,&dd,&mon,&yy)){
            struct tm t; time_t start_epoch, end_epoch; struct tm* pe; char outD[11]; char outT[6];
            double plannedDuration = total;
            double elapsed = prog + down;

            if(plannedDuration < elapsed) plannedDuration = elapsed;

            t.tm_sec=0; t.tm_min=mm; t.tm_hour=hh; t.tm_mday=dd; t.tm_mon=mon-1; t.tm_year=yy-1900;
            t.tm_wday=0; t.tm_yday=0; t.tm_isdst=-1;

            start_epoch=mktime(&t); if(start_epoch==(time_t)-1) return;
            end_epoch=start_epoch + (time_t)(plannedDuration + 0.5);
            pe=localtime(&end_epoch); if(!pe) return;
            sprintf(outD,"%02d/%02d/%04d",pe->tm_mday,pe->tm_mon+1,pe->tm_year+1900);
            sprintf(outT,"%02d:%02d",pe->tm_hour,pe->tm_min);
            if(endDayTag && endDayTag[0]!='\0') SetTagChar(endDayTag,outD);
            if(endTimeTag && endTimeTag[0]!='\0') SetTagChar(endTimeTag,outT);
        }
    }
}
