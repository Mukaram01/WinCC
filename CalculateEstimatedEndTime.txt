// CalculateEstimatedEndTime.c â€” same signature; median seconds
#include "apdefap.h"
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#define MIN_REQUIRED_SAMPLES 3
#define DEFAULT_ETA_SECONDS  3600

int compareDoubles(const void* a, const void* b); /* from CompareDoubles.c */

static int parseRuntimeSeconds(const char* runtime, double* seconds)
{
    const char* p = runtime;
    const char* colon = 0;
    char* endptr = 0;
    long hours = 0;
    long minutes = 0;

    if (!runtime || !*runtime || !seconds) {
        return 0;
    }

    while (isspace((unsigned char)*p)) {
        ++p;
    }

    colon = strchr(p, ':');
    if (!colon) {
        return 0;
    }

    hours = strtol(p, &endptr, 10);
    if (endptr != colon || hours < 0) {
        return 0;
    }

    minutes = strtol(colon + 1, &endptr, 10);
    while (isspace((unsigned char)*endptr)) {
        ++endptr;
    }

    if (*endptr != '\0' || minutes < 0 || minutes >= 60) {
        return 0;
    }

    *seconds = (double)hours * 3600.0 + (double)minutes * 60.0;
    return 1;
}

void CalculateEstimatedEndTime(const char* archiveName,
                               const char* operationTag,
                               const char* partTag,
                               const char* resultTag)
{
    UAHCONNECT hConnect = 0;
    UAHARCHIVE hArchive = 0;
    double* runTimes = 0;
    int capacity = 128, count = 0;
    double median = DEFAULT_ETA_SECONDS;

    const char* operationNumber = GetTagChar(operationTag);
    const char* partNumber      = GetTagChar(partTag);

    if (!operationNumber || !*operationNumber || !partNumber || !*partNumber) {
        SetTagDouble(resultTag, DEFAULT_ETA_SECONDS);
        return;
    }

    if (!uaConnect(&hConnect)) goto cleanup;
    if (!uaQueryArchiveByName(hConnect, archiveName, &hArchive)) goto cleanup;
    if (!uaArchiveOpen(hArchive)) goto cleanup;

    runTimes = (double*)malloc(sizeof(double) * capacity);
    if (!runTimes) goto cleanup;

    if (uaArchiveMoveFirst(hArchive)) {
        do {
            char bufOp[64] = "", bufPart[64] = "", bufRuntime[32] = "";
            double seconds = 0.0;

            uaArchiveGetFieldValueString(hArchive, 4, bufOp, sizeof(bufOp));
            uaArchiveGetFieldValueString(hArchive, 5, bufPart, sizeof(bufPart));

            if (strcmp(bufOp, operationNumber) == 0 && strcmp(bufPart, partNumber) == 0) {
                uaArchiveGetFieldValueString(hArchive, 6, bufRuntime, sizeof(bufRuntime));

                if (parseRuntimeSeconds(bufRuntime, &seconds) && seconds > 0.0) {
                    if (count >= capacity) {
                        int newcap = capacity * 2;
                        double* tmp = (double*)realloc(runTimes, sizeof(double) * newcap);
                        if (!tmp) break;
                        runTimes = tmp; capacity = newcap;
                    }
                    runTimes[count++] = seconds;
                }
            }
        } while (uaArchiveMoveNext(hArchive));
    }

    if (count >= MIN_REQUIRED_SAMPLES) {
        qsort(runTimes, count, sizeof(double), compareDoubles);
        if (count & 1) median = runTimes[count / 2];
        else           median = 0.5 * (runTimes[count / 2 - 1] + runTimes[count / 2]);
    } else {
        median = DEFAULT_ETA_SECONDS;
    }

cleanup:
    if (runTimes) free(runTimes);
    if (hArchive) { uaArchiveClose(hArchive); uaReleaseArchive(hArchive); }
    if (hConnect) { uaDisconnect(hConnect); }
    SetTagDouble(resultTag, median);
}